---
description: Core project rules - Docker-first development, cost/complexity tradeoffs, demo optimization
globs:
alwaysApply: true
---

# Enterprise Agentic AI Project

Enterprise-grade agentic AI on AWS: LangGraph + Bedrock, multi-tool orchestration, RAG, streaming.

**Current Phase:** Phase 1a (AWS Cloud Deployment)
**AWS Region:** us-east-1 (ALWAYS - never hardcode, use from settings)
**Cost Target:** $20-50/month for demo workloads
**Last Updated:** December 2025

## Single Sources of Truth

| Information | Source |
|-------------|--------|
| Package versions | DEVELOPMENT_REFERENCE.md |
| Ports/services | docker-compose.yml |
| Environment vars | .env.example |
| File existence | REPO_STATE.md |

## Docker-First Development

- **ALWAYS** use Docker Compose - never run services on host
- Commands: `docker-compose up`, `docker-compose exec backend bash`
- Hot reload via volume mounts: `./backend:/app`, `./frontend:/app`

**Common Commands:**
```bash
docker-compose up                    # Start all services
docker-compose exec backend bash     # Backend shell
docker-compose exec frontend sh      # Frontend shell
docker-compose exec backend pytest   # Run tests
docker-compose exec backend mypy src/ # Type check
docker-compose logs -f backend       # View logs
docker-compose down                  # Stop services
```

## Cost vs Complexity Tradeoffs

**When making decisions that affect cost or complexity, ALWAYS consult user with:**
- Cost impact: Monthly cost change, one-time costs, cost per request
- Complexity impact: Code complexity, maintenance burden, setup time, learning curve
- Tradeoff analysis: Pros/cons of each option
- Recommendation: Preferred option with clear rationale
- Alternative options: What was considered and why rejected

**Examples requiring consultation:**
- Caching strategies (DynamoDB vs Redis vs in-memory)
- Infrastructure choices (VPC endpoints vs public subnets, RDS Proxy vs SQLAlchemy pooling)
- Tool implementations (circuit breakers, retry logic, fallback mechanisms)
- Observability (self-hosted vs managed, logging verbosity)
- Model selection (Nova Pro vs Lite, when to use fallback)
- Database scaling (Aurora Serverless v2 ACU settings)
- Vector store choice (Pinecone Serverless vs ChromaDB)

**Cost optimization principles:**
- Acceptable cold starts: Up to 30s (show loading indicator)
- Scale to zero when idle (App Runner, DynamoDB on-demand, Aurora min 0.5 ACU)
- Target: $20-50/month for demo workloads
- Monitor token usage and cache aggressively (Phase 4+)
- Use smaller models (Nova Lite) for verification/guards when possible
- Reference: PROJECT_PLAN.md "Cost Optimization Strategies"

## Demo Experience Optimization

**Critical:** Demo must be smooth and snappy once warmed up.

**Acceptable tradeoffs:**
- Cold start: 30s acceptable (show "Warming up..." indicator)
- Setup time: Minor setup OK if demo experience is impressive
- Cost: Prefer cost efficiency over 24/7 uptime (scale to zero OK)

**Demo requirements:**
- Smooth, responsive UI during active demo
- Real-time streaming visible and impressive
- Thought process visualization (if implemented)
- Professional, polished appearance
- Reference: PROJECT_PLAN.md "Demo Presentation Guide"

## Test User Access Requirements

**Critical:** The demo must impress test users with minimal friction.

**Must be accessible via:**
- Website URL (CloudFront distribution) - single URL, no subdomains
- Simple password authentication (no complex auth flows, no OAuth, no email verification)
- Password stored in Secrets Manager (AWS) or .env (local)
- Professional login page (shadcn/ui components, polished design)

**Access flow:**
1. Test user visits CloudFront URL
2. Simple password prompt (one field, clear instructions)
3. Access to chat interface immediately after password entry
4. No additional setup, configuration, or account creation required
5. Demo should work immediately - no "getting started" tutorial needed

**Demo Quality Requirements:**
- First impression matters: Fast initial load, professional UI
- Smooth interactions: No lag, responsive feedback
- Impressive features: Real-time streaming, multi-tool orchestration visible
- Clear value proposition: Agent capabilities should be obvious from first use
- Error handling: Graceful failures with helpful messages (never show stack traces)

## Technology Stack

**Versions:** See DEVELOPMENT_REFERENCE.md "Technology Version Reference" section.
**IMPORTANT:** Always check DEVELOPMENT_REFERENCE.md before adding/updating dependencies.

**Backend:**
- Python 3.11+ (see DEVELOPMENT_REFERENCE.md for exact version)
- FastAPI ~=0.115.0, Uvicorn ~=0.32.0
- LangGraph ~=0.2.50, LangChain ~=0.3.0, LangChain-AWS ~=0.2.0
- AWS Bedrock (Nova Pro/Lite, Titan Embeddings, Claude fallback)
- PostgreSQL 15 (Docker local, Aurora Serverless v2 in AWS)
- Vector Store: Pinecone Serverless (production) or ChromaDB (local)
- Structured logging: structlog ~=24.4.0 (Phase 1b+)

**Frontend:**
- Next.js 14.2.x (App Router, static export)
- TypeScript strict mode, React 18.3+
- shadcn/ui components, Tailwind CSS 3.4+
- Native EventSource API for SSE (no Vercel AI SDK)

**Infrastructure:**
- Terraform >=1.5.0, AWS provider ~>5.0
- Docker Compose V2+ (no version key)
- GitHub Actions (CI/CD)
- AWS: App Runner, Aurora Serverless v2, CloudFront, S3, Secrets Manager

## Phase-Specific Patterns

| Phase | Checkpointing | API | Tools |
|-------|--------------|-----|-------|
| 0-1a (Current) | MemorySaver | `/api/chat` | Stubs |
| 1b+ | PostgresSaver | `/api/v1/` | Real |

## Workflow Guidelines

**Before Making Changes:**
- Check REPO_STATE.md to verify files exist before referencing them
- Verify versions in DEVELOPMENT_REFERENCE.md before updating dependencies
- If unsure on destructive steps (infra, DB, secrets), ask user first
- Keep changes small and reversible

**When to Consult User:**
- Design decisions affecting cost or complexity (see Cost vs Complexity section)
- Breaking changes to APIs or data models
- Adding new dependencies or major version updates
- Infrastructure changes (new AWS services, scaling changes)
- Security-related changes (auth flows, secrets handling)
- Changes affecting test user demo experience

**Code Review Checklist:**
- All versions match DEVELOPMENT_REFERENCE.md
- All file references exist (check REPO_STATE.md)
- No hardcoded secrets, regions, or versions
- Proper error handling and logging
- Tests updated/added for new functionality

## Research-First Development

**Critical:** Understand before implementing. Stable patterns over bleeding-edge.

### Before Writing Any Code

1. **Understand the Codebase First:**
   - Search for similar patterns already in the codebase (`grep`, `codebase_search`)
   - Read related files to understand existing conventions and abstractions
   - Check how similar features/components are implemented elsewhere
   - Identify reusable utilities, helpers, and patterns already available

2. **Verify Dependencies and Versions:**
   - Check DEVELOPMENT_REFERENCE.md for pinned versions before adding/updating packages
   - Use versions that are 2-3 months stable (not bleeding-edge, not outdated)
   - Prefer packages with active maintenance, good documentation, and large user base
   - Search for known issues with the specific version combinations you're using

3. **Research Best Practices:**
   - Look up current best practices for the specific pattern/feature being implemented
   - Check official documentation for libraries being used (LangChain, FastAPI, Next.js, etc.)
   - Verify API signatures and patterns haven't changed in newer versions
   - When using LLM/AI patterns, verify against LangChain/LangGraph current documentation

### Stability Over Novelty

**Choose patterns that are:**
- Widely adopted and battle-tested in production
- Well-documented with clear migration paths
- Supported by the library/framework maintainers
- Compatible with existing project dependencies

**Avoid:**
- Beta features or experimental APIs unless explicitly needed
- Patterns from blog posts without verifying against official docs
- Deprecated patterns that still work but have better alternatives
- Cutting-edge features that may change or have unknown bugs

### Integration Verification

**Before finalizing any implementation:**

1. **Trace the full data/control flow:**
   - Where does the data come from?
   - What transformations happen along the way?
   - Where does it end up?
   - What error conditions can occur?

2. **Check interface compatibility:**
   - Verify function signatures match what callers expect
   - Ensure type annotations are correct and complete
   - Validate that return types match what consumers need

3. **Verify imports and dependencies:**
   - Ensure all imports are available in the codebase
   - Check that dependent services/modules exist and are properly configured
   - Verify environment variables and configuration exist

4. **Run existing tests and lints:**
   - `docker-compose exec backend pytest` for Python tests
   - `docker-compose exec backend mypy src/` for type checking
   - `docker-compose exec frontend npm run lint` for frontend linting
   - Fix any failures before considering the work complete

### Research Depth by Task Type

| Task Type | Research Depth |
|-----------|----------------|
| Bug fix | Read surrounding code, understand root cause before fixing |
| New feature | Search for similar patterns, read related modules, check docs |
| Refactoring | Understand all callers and consumers, check for side effects |
| Dependency update | Check changelog, migration guide, breaking changes, compatibility |
| New integration | Read official docs, check examples, verify API stability |

### When Uncertain

- **Ask:** If unsure about patterns, cost implications, or architectural decisions, consult user
- **Prototype small:** Test patterns in isolation before integrating
- **Check compatibility:** Search for known issues with specific version combinations
- **Verify against docs:** Official documentation beats Stack Overflow or AI suggestions

## Anti-Patterns

**Never:**
- Run Python/npm directly on host instead of Docker
- Hardcode region/secrets/versions (use settings/config)
- Update config versions without updating DEVELOPMENT_REFERENCE.md first
- Link to non-existent files in docs (check REPO_STATE.md first)
- Skip error handling or user-friendly error messages
- Expose internal errors/details to end users
- Commit .env files or real API keys
- Use `any` type in TypeScript (use proper types)
- Skip type hints in Python (required on all functions)
- Skip docstrings (required for all functions/classes)

## Key Files

- PHASE_1A_HOW_TO_GUIDE.md - Current phase implementation steps
- docs/completed-phases/PHASE_0_HOW_TO_GUIDE.md - Completed Phase 0 guide (archived)
- DEVELOPMENT_REFERENCE.md - Specs and versions
- REPO_STATE.md - What files exist

## Local URLs

- Frontend: http://localhost:3000
- Backend: http://localhost:8000
- API Docs: http://localhost:8000/docs

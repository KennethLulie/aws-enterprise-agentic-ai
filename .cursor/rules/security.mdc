---
description: Security rules - secrets management, SQL safety, input validation
globs:
alwaysApply: true
---

# Security Rules

## Secrets Management

- Never commit .env files (gitignored)
- Use .env.example as template (no real keys)
- Production: AWS Secrets Manager
- Document new env vars in .env.example + docs
- Test user access: Password stored in Secrets Manager (AWS) or .env (local), simple password auth only

## SQL Safety

**Critical:** SQL injection prevention is mandatory.

**Parameterized Queries:**
- Parameterized queries ONLY - NEVER use string formatting or f-strings
- Use SQLAlchemy ORM or parameterized queries with psycopg2
- Example:
```python
# CORRECT - Parameterized
result = session.execute(
    text("SELECT * FROM users WHERE id = :user_id"),
    {"user_id": user_id}
)

# WRONG - String formatting (NEVER DO THIS)
result = session.execute(f"SELECT * FROM users WHERE id = {user_id}")
```

**Table/Column Whitelisting:**
- Define `ALLOWED_TABLES` constant with whitelist
- Validate table/column names against whitelist before query
- Reject any table/column not in whitelist
- Example:
```python
ALLOWED_TABLES = {"users", "products", "orders"}

def validate_table(table_name: str) -> bool:
    if table_name not in ALLOWED_TABLES:
        raise ValueError(f"Table {table_name} not allowed")
    return True
```

**SQL Query Restrictions:**
- Only allow SELECT queries (no INSERT, UPDATE, DELETE for demo)
- Limit query complexity (prevent DoS via expensive queries)
- Set query timeout (e.g., 5 seconds max)
- Limit result set size (e.g., max 1000 rows)

**Pydantic Validation:**
- Validate all SQL query inputs with Pydantic
- Type checking: Ensure IDs are integers, strings are strings
- Length limits: Prevent extremely long queries

## Input Validation

**General Principles:**
- Pydantic models for ALL API inputs (no exceptions)
- Validate and sanitize user input before processing
- User-friendly error messages, NEVER expose internal details
- Reject malformed input early (fail fast)

**Pydantic Validation Pattern:**
```python
from pydantic import BaseModel, Field, validator

class ChatRequest(BaseModel):
    message: str = Field(..., min_length=1, max_length=10000)
    conversation_id: str | None = None

    @validator('message')
    def validate_message(cls, v):
        # Additional custom validation
        if not v.strip():
            raise ValueError("Message cannot be empty")
        return v.strip()
```

**Input Sanitization:**
- Strip whitespace from strings
- Validate length limits (prevent DoS)
- Validate format (email, URL, etc.) when applicable
- Escape special characters for SQL (use parameterized queries)

## Input/Output Verification (Phase 3+)

**SLM Guards:**
- Use Nova Lite for input/output verification (cheaper than Nova Pro)
- Verify user input before processing (prevent prompt injection, malicious input)
- Verify agent output before sending to user (prevent harmful content)
- Cost optimization: Smaller model sufficient for verification

**Input Verification Pattern:**
```python
from langchain_aws import ChatBedrock
from src.config.settings import Settings

async def verify_input(user_input: str) -> bool:
    """Verify user input is safe to process."""
    from src.config.settings import Settings
    settings = Settings()

    verification_model = ChatBedrock(
        model_id=settings.bedrock_verification_model_id,
        region_name=settings.aws_region
    )

    prompt = f"Is this input safe and appropriate? {user_input}"
    response = await verification_model.ainvoke(prompt)
    return "safe" in response.content.lower()
```

**Output Verification Pattern:**
```python
async def verify_output(agent_output: str) -> tuple[bool, str]:
    """Verify agent output is safe to send to user."""
    prompt = f"Check if this response is safe: {agent_output}"
    response = await verification_model.ainvoke(prompt)
    is_safe = "safe" in response.content.lower()
    return is_safe, agent_output if is_safe else "I cannot provide that information."
```

**Verification Failure Handling:**
- Input fails: Return user-friendly error, don't process
- Output fails: Return safe default message, log incident
- Never expose why verification failed to user

## Rate Limiting

**Implementation:**
- Rate limit by IP address (not user ID for simple password auth)
- Configurable limit: Default 10 requests/minute per IP
- Use in-memory store for local (Redis-like), Redis for production
- Return 429 Too Many Requests with Retry-After header

**Rate Limiting Pattern:**
```python
from fastapi import Request, HTTPException
from collections import defaultdict
from datetime import datetime, timedelta

# Simple in-memory rate limiter (use Redis in production)
rate_limits: dict[str, list[datetime]] = defaultdict(list)

def check_rate_limit(request: Request, limit: int = 10, window: int = 60):
    """Check if request exceeds rate limit."""
    ip = request.client.host
    now = datetime.now()

    # Clean old entries
    rate_limits[ip] = [
        ts for ts in rate_limits[ip]
        if now - ts < timedelta(seconds=window)
    ]

    # Check limit
    if len(rate_limits[ip]) >= limit:
        raise HTTPException(
            status_code=429,
            detail="Rate limit exceeded. Please try again later.",
            headers={"Retry-After": str(window)}
        )

    # Record request
    rate_limits[ip].append(now)
```

**Rate Limit Configuration:**
- Environment variable: `RATE_LIMIT_PER_MINUTE=10`
- Different limits for different endpoints if needed
- Exempt health check endpoint from rate limiting
- Log rate limit violations for monitoring

## AWS Configuration

**Region:**
- Region is ALWAYS us-east-1 unless explicitly changed
- Load from environment variable: `AWS_REGION` (default: us-east-1)
- Never hardcode region in code

**Credentials:**
- Local development: Credentials in .env file (gitignored)
- AWS production: Use IAM roles (App Runner, Lambda)
- NEVER hardcode credentials in code
- NEVER commit credentials to repository

**Secrets Manager (Production):**
- Store all secrets in AWS Secrets Manager when `ENVIRONMENT=aws`
- Load secrets on application startup
- Cache secrets in memory (don't fetch on every request)
- Fallback to .env for local development
- Reference: `backend/src/config/settings.py` (created in Phase 0)

**Secrets Manager Pattern:**
```python
import boto3
from botocore.exceptions import ClientError
from src.config.settings import Settings

def get_secret(secret_name: str) -> dict:
    """Get secret from AWS Secrets Manager."""
    settings = Settings()
    client = boto3.client('secretsmanager', region_name=settings.aws_region)
    try:
        response = client.get_secret_value(SecretId=secret_name)
        return json.loads(response['SecretString'])
    except ClientError as e:
        logger.error(f"Failed to get secret: {e}")
        raise
```

## Core Component Changes

**When changing core components** (vector store, database, LLM, auth, caching, logging, checkpointing):

1. **Search codebase:** `grep -r "component_name" backend/ frontend/ terraform/`
2. **Update all references:**
   - Backend code (settings, initialization, usage)
   - Frontend code (if affects API)
   - `.env.example` (add/remove variables)
   - `docker-compose.yml` (environment variables, services)
   - Terraform (if infrastructure change)
   - Tests (update mocks, test data)
   - Documentation (README, DEVELOPMENT_REFERENCE.md, etc.)
3. **Update REPO_STATE.md** (if files added/removed)
4. **Security review:** Ensure no secrets exposed, proper validation

## Authentication

**Password Authentication (Simple):**
- Single password for demo (no user accounts)
- Password stored in Secrets Manager (AWS) or .env (local)
- Hash password before comparison (use bcrypt or similar)
- Session management: Use secure cookies or JWT tokens
- Password validation: Minimum length, complexity (optional for demo)

**Session Management:**
- Generate session token on successful login
- Store session in secure HTTP-only cookie
- Validate session on protected routes
- Expire session after inactivity (e.g., 24 hours)
- Clear session on logout

**Protected Routes:**
- Middleware to check authentication
- Return 401 Unauthorized if not authenticated
- Redirect to login page if not authenticated (frontend)

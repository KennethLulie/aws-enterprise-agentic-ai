---
description: Python backend development - FastAPI, code standards, error handling, streaming
globs:
  - backend/**
alwaysApply: false
---

# Backend Development Rules

## Code Standards

- **Type hints REQUIRED** on all functions
- **Docstrings REQUIRED** (Google style) for all functions/classes
- Absolute imports: `from src.agent.nodes.chat import chat_node`
- Tools: Black, Ruff, mypy (versions in DEVELOPMENT_REFERENCE.md)

## File Structure

```
backend/src/
├── agent/          # LangGraph agent (→ See agent.mdc)
│   ├── nodes/      # Node functions
│   ├── tools/      # Tool definitions
│   ├── state.py    # State schema
│   └── graph.py    # Graph definition
├── api/            # FastAPI routes
│   ├── routes/
│   └── middleware/
└── config/         # Settings
```

**Naming:** snake_case for files, functions, variables

## Docker Commands

```bash
docker-compose exec backend bash      # Shell
docker-compose exec backend pytest    # Tests
docker-compose exec backend mypy src/ # Type check
docker-compose logs -f backend        # Logs
```

→ See [_workflow.mdc] for full Docker commands

## Before Committing

```bash
pre-commit run --all-files
docker-compose exec backend pytest
docker-compose exec backend mypy src/
```

## Error Handling

### Retry with Exponential Backoff

```python
from tenacity import retry, stop_after_attempt, wait_exponential
import structlog

logger = structlog.get_logger()

@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
async def call_bedrock(messages: list) -> dict:
    try:
        return await bedrock_client.invoke(messages)
    except Exception as e:
        logger.error("bedrock_call_failed", error=str(e))
        raise
```

### User-Friendly Errors

```python
# ✅ CORRECT
raise HTTPException(status_code=500, detail="Unable to process request")

# ❌ WRONG - Never expose internals
raise HTTPException(status_code=500, detail=str(e))
```

### Fallback Patterns

- Bedrock fails → Fallback to Claude
- Tool fails → Log, return partial answer, continue
- Database fails → Return cached data or user-friendly error

## Streaming (SSE)

```python
from fastapi.responses import StreamingResponse
import json

async def stream_response(conversation_id: str, request: Request):
    async for chunk in agent.astream(state):
        yield f"data: {json.dumps(chunk)}\n\n"
        if await request.is_disconnected():
            break

@app.post("/api/chat")
async def chat_stream(request: Request):
    return StreamingResponse(
        stream_response(conversation_id, request),
        media_type="text/event-stream"
    )
```

**Format:** `data: {json}\n\n` for each event

**Error in stream:**
```python
yield f'data: {{"type": "error", "message": "Something went wrong"}}\n\n'
```

## Logging

Use structlog with JSON output:

```python
import structlog

logger = structlog.get_logger()

logger.info(
    "tool_executed",
    tool="search",
    conversation_id=conversation_id,
    latency_ms=150,
    success=True
)
```

**Include context:** conversation_id, tool, latency_ms, error_type

## Testing

```python
import pytest
from unittest.mock import AsyncMock

@pytest.mark.asyncio
async def test_endpoint(mocker):
    mock_agent = mocker.patch("src.api.routes.chat.agent")
    mock_agent.astream = AsyncMock(return_value=[...])

    response = await client.post("/api/chat", json={"message": "test"})

    assert response.status_code == 200
```

**Test coverage:**
- Mock external services (Bedrock, Tavily, FMP)
- Test error recovery paths
- Test streaming format

## Cost Optimization

| Strategy | Implementation |
|----------|----------------|
| Use Nova Lite for guards | Cheaper than Nova Pro |
| Cache embeddings | Don't regenerate |
| Batch tool calls | When possible |
| Monitor token usage | Log per request |

→ See [agent.mdc] for LangGraph patterns
→ See [_security.mdc] for input validation
→ See [aws.mdc] for Bedrock configuration
